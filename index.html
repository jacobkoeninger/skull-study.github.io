<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>üíÄ Radiology Study Games</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Roboto:wght@300;400;700&display=swap');

        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            background: #1a1a1a;
            background-image: 
                linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)),
                url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI2MCIgaGVpZ2h0PSI2MCI+CiAgPHBhdGggZD0iTTAgMGg2MHY2MEgweiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Ik0zMCAyYzE1LjUgMCAyOCAxMi41IDI4IDI4UzQ1LjUgNTggMzAgNTggMiA0NS41IDIgMzAgMTQuNSAyIDMwIDJ6IiBmaWxsPSJub25lIiBzdHJva2U9IiMzMzMiIHN0cm9rZS13aWR0aD0iMSIvPgo8L3N2Zz4=');
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            padding: 2rem 0;
        }

        .container {
            text-align: center;
            background: rgba(15, 15, 15, 0.95);
            padding: 3rem 1.5rem;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.1);
            max-width: 800px;
            width: 90%;
            position: relative;
            margin: 180px auto 2rem;
        }

        .skull-container {
            position: absolute;
            top: -180px;
            left: 50%;
            transform: translateX(-50%);
            width: 180px;
            height: 180px;
            perspective: 1000px;
            pointer-events: none;
        }

        .skull {
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .skull svg {
            width: 100%;
            height: 100%;
            fill: white;
            filter: drop-shadow(0 0 15px rgba(0, 255, 255, 0.3));
        }

        .eye-socket {
            fill: black;
        }

        .nose {
            fill: black;
        }

        .teeth-row {
            fill: none;
            stroke: black;
            stroke-width: 2;
        }

        h1 {
            font-family: 'Cinzel', serif;
            color: #00ffff;
            font-size: 2.5rem;
            margin-bottom: 2rem;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            margin-top: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
        }


        @keyframes skull-bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        p {
            color: #ffffff;
            font-size: 1.2rem;
            margin-bottom: 2rem;
        }

        .game-links {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .game-card {
            background: rgba(30, 30, 30, 0.9);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 10px;
            padding: 1.5rem;
            transition: all 0.3s ease;
            text-decoration: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.4);
        }

        .game-icon {
            width: 64px;
            height: 64px;
            margin-bottom: 1rem;
            filter: invert(1) brightness(0.8) sepia(1) hue-rotate(175deg) saturate(3);
        }

        .game-title {
            color: #ffffff;
            font-family: 'Cinzel', serif;
            font-size: 1.2rem;
            margin: 0;
        }

        .game-description {
            color: #aaaaaa;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }
            
            h1 {
                font-size: 2rem;
                margin-top: 1rem;
                flex-direction: column;
                gap: 0.5rem;
            }

            .skull-container {
                top: -150px;
                width: 150px;
                height: 150px;
            }

            .game-links {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .game-card {
                padding: 1rem;
            }

            .game-icon {
                width: 48px;
                height: 48px;
            }

            .game-title {
                font-size: 1.1rem;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 2rem 1rem;
                margin: 120px auto 1rem;
            }

            .skull-container {
                top: -100px;
                width: 100px;
                height: 100px;
            }

            h1 {
                font-size: 1.75rem;
            }

            .game-description {
                font-size: 0.85rem;
            }
        }

        .credits-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            justify-content: center;
        }

        .credit-text {
            background: rgba(15, 15, 15, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.1);
            border-radius: 25px;
            padding: 0.6rem 1.2rem;
            color: #aaaaaa;
            font-size: 0.9rem;
            display: inline-flex;
            align-items: center;
            transition: all 0.3s ease;
        }

        .credit-text:hover {
            border-color: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
            transform: translateY(-3px);
        }

        .credit-heart {
            color: #ff6b6b;
            margin-right: 0.5rem;
            animation: pulse 1.5s infinite;
        }

        .credit-name {
            color: #00ffff;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @media (max-width: 480px) {
            .credit-text {
                font-size: 0.8rem;
                padding: 0.5rem 1rem;
            }
        }

        #background-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.4;
        }
    </style>
</head>
<body>
    <canvas id="background-canvas"></canvas>
    <div class="container">
        <div class="skull-container">
            <div class="skull">
                <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <!-- Main skull shape - exactly like emoji -->
                    <path d="M50 5
                        C25 5 15 25 15 45
                        C15 65 30 85 50 85
                        C70 85 85 65 85 45
                        C85 25 75 5 50 5Z" />
                    
                    <!-- Left eye socket - exactly like emoji -->
                    <circle class="eye-socket" cx="35" cy="45" r="13" />
                    
                    <!-- Right eye socket - exactly like emoji -->
                    <circle class="eye-socket" cx="65" cy="45" r="13" />
                    
                    <!-- Nose - triangle shape like emoji -->
                    <path class="nose" d="M43 55 L57 55 L50 68 Z" />
                    
                    <!-- Teeth rows - exactly like emoji -->
                    <path class="teeth-row" d="M30 70 L70 70" />
                    <path class="teeth-row" d="M30 75 L70 75" />
                    <path class="teeth-row" d="M35 70 L35 75" />
                    <path class="teeth-row" d="M45 70 L45 75" />
                    <path class="teeth-row" d="M55 70 L55 75" />
                    <path class="teeth-row" d="M65 70 L65 75" />
                </svg>
            </div>
        </div>
        <h1>Radiology Study Games</h1>
        <p>Master skull anatomy through interactive learning</p>
        
        <div class="game-links">
            <a href="Matching Pairs/matching_pairs.html" class="game-card">
                <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTIxLDJIOUEzLDMgMCAwLDAgNiw1VjE5QTMsMyAwIDAsMCA5LDIySDIxQTMsMyAwIDAsMCAyNCwxOVY1QTMsMyAwIDAsMCAyMSwyTTIzLDE5QTIsMiAwIDAsMSAyMSwyMUg5QTIsMiAwIDAsMSA3LDE5VjVBMiwyIDAgMCwxIDksM0gyMUEyLDIgMCAwLDEgMjMsNVYxOU0zLDRWMThBMywzIDAgMCwwIDYsMjFWMjBBMiwyIDAgMCwxIDQsMThWNEg2VjNIM0ExLDEgMCAwLDAgMiw0TTEzLDEwQTMsMyAwIDAsMCAxMCwxM0EzLDMgMCAwLDAgMTMsMTZBMywzIDAgMCwwIDE2LDEzQTMsMyAwIDAsMCAxMywxME0xMywxNUEyLDIgMCAwLDEgMTEsMTNBMiwyIDAgMCwxIDEzLDExQTIsMiAwIDAsMSAxNSwxM0EyLDIgMCAwLDEgMTMsMTVaIi8+PC9zdmc+" class="game-icon" alt="Matching icon">
                <h3 class="game-title">Matching Pairs</h3>
                <p class="game-description">Match radiographs with their correct views</p>
            </a>
            
            <a href="FLIP GAME/flip_game.html" class="game-card">
                <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTIxLDE5VjVDMjEsMy44OSAyMC4xLDMgMTksM0g1QzMuODksMyAzLDMuODkgMyw1VjE5QzMsMjAuMSAzLjg5LDIxIDUsMjFIMTlDMjAuMSwyMSAyMSwxOS4xIDIxLDE5TTguNSw5LjY2TDEwLjgzLDEyTDguNSwxNC4zM1YxMS41SDRWMTIuNUg3LjE3TDUuNSwxNC4xN0w2LjE3LDE0LjgzTDksMTJMNi4xNyw5LjE3TDUuNSw5LjgzTDcuMTcsMTEuNUg0VjEyLjVINy41VjkuNjZWOS42Nk0xOS41LDkuNjZMMTcuMTcsMTJMMTkuNSwxNC4zM1YxMS41SDI0VjEyLjVIMjAuODNMMjIuNSwxNC4xN0wyMS44MywxNC44M0wxOSwxMkwyMS44Myw5LjE3TDIyLjUsOS44M0wyMC44MywxMS41SDI0VjEyLjVIMjAuNVY5LjY2VjkuNjZaIi8+PC9zdmc+" class="game-icon" alt="Flip icon">
                <h3 class="game-title">Flip Game</h3>
                <p class="game-description">Study radiographic views and their descriptions</p>
            </a>
            
            <a href="skull-landmarks-game/index.html" class="game-card">
                <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTEyLDJBMTAsMTAgMCAwLDAgMiwxMkExMCwxMCAwIDAsMCAxMiwyMkExMCwxMCAwIDAsMCAyMiwxMkExMCwxMCAwIDAsMCAxMiwyTTEyLDRBOCw4IDAgMCwxIDIwLDEyQTgsOCAwIDAsMSAxMiwyMEE4LDggMCAwLDEgNCwxMkE4LDggMCAwLDEgMTIsNE0xMiw2QTYsNiAwIDAsMCA2LDEyQTYsNiAwIDAsMCAxMiwxOEE2LDYgMCAwLDAgMTgsMTJBNiw2IDAgMCwwIDEyLDZNMTIsOEE0LDQgMCAwLDEgMTYsMTJBNCw0IDAgMCwxIDEyLDE2QTQsNCAwIDAsMSA4LDEyQTQsNCAwIDAsMSAxMiw4WiIvPjwvc3ZnPg==" class="game-icon" alt="Target icon">
                <h3 class="game-title">Skull Landmarks</h3>
                <p class="game-description">Learn and identify important skull landmarks</p>
            </a>
            
            <a href="pdf-viewer.html" class="game-card">
                <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTIwLDJINEEyLDIgMCAwLDAgMiw0VjIyTDYsMThIMjBBMiwyIDAgMCwwIDIyLDE2VjRDMjIsMi44OSAyMS4xLDIgMjAsMk0xMyw5SDE1VjE1SDEzVjlNOSw5SDExVjE1SDlWOVoiLz48L3N2Zz4=" class="game-icon" alt="PDF icon">
                <h3 class="game-title">Headwork Learning Tool</h3>
                <p class="game-description">Multi-page PDF study material for radiographic techniques</p>
            </a>
            
            <a href="study-materials/index.html" class="game-card study-card">
                <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTE5IDVWMTlINVY1SDE5TTIxIDNIN0M1LjkgMyA1IDMuOSA1IDVWMjFDNSAyMi4xIDUuOSAyMyA3IDIzSDE5QzIwLjEgMjMgMjEgMjIuMSAyMSAyMVYzTTE0IDEwSDEwVjExSDEzLjVDMTMuNjcgMTEgMTMuODQgMTEuMDUgMTQgMTEuMTVDMTQuMjIgMTEuMjUgMTQuNDEgMTEuNCAxNC41NSAxMS42QzE0LjcgMTEuNzUgMTQuOCAxMS45NSAxNC44NSAxMi4yQzE0LjkgMTIuNDUgMTQuOSAxMi43IDE0Ljg1IDEzSDEwVjE0SDE0Ljg1QzE0LjkgMTQuMyAxNC45IDE0LjU1IDE0Ljg1IDE0LjhDMTQuOCAxNS4wNSAxNC43IDE1LjI1IDE0LjU1IDE1LjRDMTQuNDEgMTUuNiAxNC4yMiAxNS43NSAxNCAxNS44NUMxMy44NCAxNS45NSAxMy42NyAxNiAxMy41IDE2SDEwVjE3SDE0QzE0LjU1IDE3IDE1LjA1IDE2LjggMTUuNDUgMTYuNDVDMTUuODUgMTYuMDUgMTYgMTUuNTUgMTYgMTVDMTYgMTQuNDUgMTUuODUgMTQgMTUuNSAxMy42QzE1Ljg1IDEzLjIgMTYgMTIuNzUgMTYgMTIuMjVDMTYgMTEuNzUgMTUuOCAxMS4yNSAxNS40NSAxMC44NUMxNS4wNSAxMC41IDE0LjU1IDEwLjI1IDE0IDEwTTkgMTBIOVYxN0g5TDcgMTBIOVoiPjwvcGF0aD48L3N2Zz4=" class="game-icon" alt="Educational Resources icon">
                <h3 class="game-title">Study Materials</h3>
                <p class="game-description">Interactive learning aids and mnemonics</p>
            </a>
        </div>
    </div>

    <div class="credits-container">
        <div class="credit-text">
            <span class="credit-heart">‚ù§</span> Created with anatomical precision by <span class="credit-name">&nbsp;Candy&nbsp;</span> & <span class="credit-name">&nbsp;Breyden &nbsp;</span>
        </div>
    </div>

    <script>
        document.addEventListener('mousemove', (e) => {
            const skull = document.querySelector('.skull');
            const skullRect = skull.getBoundingClientRect();

            // Calculate the center of the skull
            const skullCenterX = skullRect.left + skullRect.width / 2;
            const skullCenterY = skullRect.top + skullRect.height / 2;

            // Calculate the angle between the mouse and the skull center
            const deltaX = e.clientX - skullCenterX;
            const deltaY = e.clientY - skullCenterY;

            // Calculate rotation angles (limit the rotation range)
            const rotateY = Math.min(Math.max(deltaX * 0.02, -8), 8);
            const rotateX = Math.min(Math.max(-deltaY * 0.02, -8), 8);

            // Apply the rotation while maintaining the float animation
            skull.style.transform = `translateY(var(--float-offset, 0px)) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
        });

        // Background animation
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('background-canvas');
            const ctx = canvas.getContext('2d');
            let particles = [];
            let mouseX = window.innerWidth / 2;
            let mouseY = window.innerHeight / 2;
            const particleCount = 100;
            const baseConnectionDistance = 180;
            const layerCount = 3;
            
            // Color palette
            const primaryColor = '0, 255, 255'; // Cyan
            const secondaryColor = '255, 255, 255'; // White
            const accentColor = '255, 107, 107'; // Light red (matching heart)
            
            // Set canvas size
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            // Track mouse position for interactive effects
            document.addEventListener('mousemove', function(e) {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            // Create particles with depth layers
            function createParticles() {
                particles = [];
                for (let layer = 0; layer < layerCount; layer++) {
                    const layerDepth = (layer + 1) / layerCount;
                    const layerParticleCount = Math.floor(particleCount * (1 - (layer * 0.3)));
                    
                    for (let i = 0; i < layerParticleCount; i++) {
                        // Determine color based on layer and randomness
                        let colorBase;
                        const colorRoll = Math.random();
                        
                        if (colorRoll < 0.65) {
                            colorBase = primaryColor; // Cyan (most common)
                        } else if (colorRoll < 0.95) {
                            colorBase = secondaryColor; // White (less common)
                        } else {
                            colorBase = accentColor; // Accent (rare)
                        }
                        
                        particles.push({
                            x: Math.random() * canvas.width,
                            y: Math.random() * canvas.height,
                            z: layerDepth, // Z-depth for parallax effect
                            radius: (Math.random() * 2 + 0.8) / layerDepth, // Larger particles in front
                            color: colorBase,
                            baseSpeedX: (Math.random() * 0.8 - 0.4) * layerDepth,
                            baseSpeedY: (Math.random() * 0.8 - 0.4) * layerDepth,
                            speedX: 0,
                            speedY: 0,
                            pulseSpeed: Math.random() * 0.02 + 0.01,
                            pulseAmount: Math.random() * 0.5 + 0.5,
                            pulseOffset: Math.random() * Math.PI * 2,
                            history: [], // For trailing effect
                            connectionStrength: Math.random() * 0.5 + 0.5,
                            lastUpdate: Date.now()
                        });
                    }
                }
            }
            
            // Calculate pulse values for dynamic effects
            function calculatePulse(particle, time) {
                return Math.sin(time * particle.pulseSpeed + particle.pulseOffset) * particle.pulseAmount;
            }
            
            // Draw particles with enhanced visual effects
            function drawParticles(timestamp) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const time = timestamp / 1000;
                
                // Draw connections between particles
                for (let i = 0; i < particles.length; i++) {
                    const p1 = particles[i];
                    const pulse1 = calculatePulse(p1, time);
                    
                    // Calculate distance from mouse for interactive effects
                    const mouseDistX = p1.x - mouseX;
                    const mouseDistY = p1.y - mouseY;
                    const mouseDistance = Math.sqrt(mouseDistX * mouseDistX + mouseDistY * mouseDistY);
                    const mouseInfluence = Math.max(0, 1 - (mouseDistance / (canvas.width * 0.3)));
                    
                    // Draw connections
                    for (let j = i + 1; j < particles.length; j++) {
                        const p2 = particles[j];
                        const pulse2 = calculatePulse(p2, time);
                        
                        // Calculate adjusted connection distance based on layer and mouse proximity
                        const connectionDistance = baseConnectionDistance * 
                                                (1 + mouseInfluence * 0.3) * 
                                                Math.min(p1.z, p2.z);
                        
                        const dx = p1.x - p2.x;
                        const dy = p1.y - p2.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < connectionDistance) {
                            // Calculate opacity based on distance and pulses
                            const baseOpacity = (1 - distance / connectionDistance);
                            const pulseEffect = (pulse1 + pulse2) * 0.1;
                            const finalOpacity = Math.min(0.8, (baseOpacity + pulseEffect) * 0.3);
                            
                            // Determine color based on particle types
                            let connectionColor;
                            if (p1.color === accentColor || p2.color === accentColor) {
                                // If either particle is accent, use accent with reduced opacity
                                connectionColor = `rgba(${accentColor}, ${finalOpacity * 0.7})`;
                            } else if (p1.color === p2.color) {
                                // Same color particles
                                connectionColor = `rgba(${p1.color}, ${finalOpacity})`;
                            } else {
                                // Different color particles - blend
                                connectionColor = `rgba(${primaryColor}, ${finalOpacity})`;
                            }
                            
                            // Draw connection with dynamic width based on connection strength
                            const connectionWidth = 0.5 + 
                                                (p1.connectionStrength * p2.connectionStrength * 0.8) + 
                                                (mouseInfluence * 0.5);
                            
                            ctx.beginPath();
                            ctx.strokeStyle = connectionColor;
                            ctx.lineWidth = connectionWidth * Math.min(p1.z, p2.z);
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.stroke();
                        }
                    }
                }
                
                // Draw particles with glow effects
                for (let i = 0; i < particles.length; i++) {
                    const p = particles[i];
                    const pulse = calculatePulse(p, time);
                    
                    // Calculate mouse influence for this particle
                    const mouseDistX = p.x - mouseX;
                    const mouseDistY = p.y - mouseY;
                    const mouseDistance = Math.sqrt(mouseDistX * mouseDistX + mouseDistY * mouseDistY);
                    const mouseInfluence = Math.max(0, 1 - (mouseDistance / (canvas.width * 0.2)));
                    
                    // Calculate dynamic radius with pulse and mouse influence
                    const dynamicRadius = p.radius * (1 + pulse * 0.3 + mouseInfluence * 0.5);
                    
                    // Draw glow effect
                    const gradientSize = dynamicRadius * (3 + mouseInfluence * 2);
                    const gradient = ctx.createRadialGradient(
                        p.x, p.y, 0,
                        p.x, p.y, gradientSize
                    );
                    
                    // Determine opacity based on pulse and mouse
                    const innerOpacity = 0.7 + (pulse * 0.15) + (mouseInfluence * 0.3);
                    const midOpacity = (0.3 + pulse * 0.15) * p.z;
                    
                    gradient.addColorStop(0, `rgba(${p.color}, ${innerOpacity})`);
                    gradient.addColorStop(0.4, `rgba(${p.color}, ${midOpacity})`);
                    gradient.addColorStop(1, `rgba(${p.color}, 0)`);
                    
                    ctx.beginPath();
                    ctx.fillStyle = gradient;
                    ctx.arc(p.x, p.y, gradientSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw core of particle
                    ctx.beginPath();
                    ctx.fillStyle = `rgba(${p.color}, ${0.7 + pulse * 0.3})`;
                    ctx.arc(p.x, p.y, dynamicRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Update particle positions with more dynamic movement
            function updateParticles() {
                const now = Date.now();
                const mouseInfluenceRadius = canvas.width * 0.2;
                
                for (let i = 0; i < particles.length; i++) {
                    const p = particles[i];
                    const deltaTime = (now - p.lastUpdate) / 16; // normalize to ~60fps
                    p.lastUpdate = now;
                    
                    // Calculate mouse influence
                    const dx = p.x - mouseX;
                    const dy = p.y - mouseY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Apply base speed
                    p.speedX = p.baseSpeedX;
                    p.speedY = p.baseSpeedY;
                    
                    // Apply mouse influence if close enough
                    if (distance < mouseInfluenceRadius) {
                        const force = (1 - distance / mouseInfluenceRadius) * 0.2;
                        const angle = Math.atan2(dy, dx);
                        
                        // Particles are gently pushed away from cursor
                        p.speedX += Math.cos(angle) * force * p.z;
                        p.speedY += Math.sin(angle) * force * p.z;
                    }
                    
                    // Apply slight flow field effect for more organic movement
                    const noiseOffsetX = p.x * 0.002;
                    const noiseOffsetY = p.y * 0.002;
                    const noiseValue = Math.sin(noiseOffsetX) * Math.cos(noiseOffsetY) * 0.1;
                    
                    p.speedX += noiseValue * p.z;
                    p.speedY += noiseValue * p.z * 0.8;
                    
                    // Update position with deltaTime for consistent movement
                    p.x += p.speedX * deltaTime;
                    p.y += p.speedY * deltaTime;
                    
                    // Edge wrapping with buffer
                    const buffer = 50;
                    if (p.x < -buffer) p.x = canvas.width + buffer;
                    if (p.x > canvas.width + buffer) p.x = -buffer;
                    if (p.y < -buffer) p.y = canvas.height + buffer;
                    if (p.y > canvas.height + buffer) p.y = -buffer;
                    
                    // Store position history for potential trails
                    p.history.unshift({x: p.x, y: p.y});
                    if (p.history.length > 5) {
                        p.history.pop();
                    }
                }
            }
            
            // Animation loop with timing parameter
            function animate(timestamp) {
                updateParticles();
                drawParticles(timestamp);
                requestAnimationFrame(animate);
            }
            
            // Initialize
            resizeCanvas();
            createParticles();
            requestAnimationFrame(animate);
            
            // Handle resizing
            window.addEventListener('resize', function() {
                resizeCanvas();
                createParticles();
            });
        });
    </script>
</body>
</html>

